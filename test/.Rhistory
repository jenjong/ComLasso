abline(h = 0)
legend("topright", legend = c("filtered", "original"), col = c("red", "blue"),
lty = c(1,1))
legend("topright", legend = c("filtered", "original"), col = c("red", "blue"),
lty = c(2,2) )
plot(x,v1, col = 'red', type = 'l')
lines(x-0.5,f(x)*6.5, col='blue')
plot(x,v1, col = 'red', type = 'l')
# concvolution
v1  = c()
v1  = c()
for (i in 1:length(x))
{
x0 <- x[i]
yy <- g(x-x0)
yy[abs(yy) == Inf] = 0
v1[i] <- sum(f(x)*yy)
}
plot(x,v1, col = 'red', type = 'l')
lines(x-0.5,f(x)*6.5, col='blue')
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x-0.5,f(x)*6.5, col='blue')
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x-0.5,f(x)*6.5, col='blue')
legend("topright", legend = c("filtered", "scaled"), col = c("red", "blue"),
lty = c(2,2) )
legend("topright", legend = c("filtered", "origal with scaling"), col = c("red", "blue"),
lty = c(2,2) )
x <- seq(-4,8, length = 1001)
f <- function(x)  0.7* dnorm(x,0,1/2) + 0.3*dnorm(x,3,1)
tf <- function(x) {
v = rep(0, length(x))
idx <- x>=-4 & x<=8
v[idx]<-  f(x[idx])-1/12
v
}
plot(x,tf(x), type='l', col = 'blue')
g <- function(x) {
dbeta(x,1/2,1/2)*0.1
}
plot(x, g(-x), xlim = c(-1.5,0.5),type = 'l', main = "g(x)")
tg <- function(x) {
v = rep(0, length(x))
idx <- x>0 & x<1
v[idx]<-  g(x[idx])-0.1
v
}
plot(x,tg(x), xlim = c(-0.5,1.5),type = 'l', main = "normalized K(x)", col = 'red')
abline(h=0, lty = 2)
##
v1  = c()
for (i in 1:length(x))
{
x0 <- x[i]
yy <- tg(x-x0)
yy[abs(yy) == Inf] = 0
v1[i] <- sum(tf(x)*yy)
}
plot(x,v1, col = 'red', type = 'l', ylim = c(-0.5,0.5), lty = 2,
ylab = expression( paste(tilde(f),"*", tilde(g))),
main = "similarity of normalized signals")
lines(x,tf(x), col='blue', lty = 2)
abline(h = 0)
legend("topright", legend = c("filtered", "original"), col = c("red", "blue"),
lty = c(2,2) )
# concvolution
v1  = c()
for (i in 1:length(x))
{
x0 <- x[i]
yy <- g(x-x0)
yy[abs(yy) == Inf] = 0
v1[i] <- sum(f(x)*yy)
}
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x-0.5,f(x)*6.5, col='blue')
legend("topright", legend = c("filtered", "origal with scaling"), col = c("red", "blue"),
lty = c(2,2) )
dbeta(x,1/2,1/2)*0.1
g(-x)
x
plot(-x, g(x), xlim = c(-1.5,0.5),type = 'l', main = "g(x)")
plot(x,tf(x), type='l', col = 'blue')
plot(x,f(x), type='l', col = 'blue')
abline(h = 0)
plot(x,tf(x), type='l', col = 'blue')
abline(h = 0)
plot(x,f(x), type='l', col = 'blue', main= "f(t)")
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
plot(x,tf(x), type='l', col = 'blue', xlab = "t",
ylab= expression(paste(tilde(f),"(t)")))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(mar = c(1,1,1,1))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(1,1,1,1))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(2,1,1,1))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(2,1,3,1))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(2,3,3,1))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(2,3,3,2))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(oma = c(2,4,3,2))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
?par
par(mai = c(2,4,3,2))
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(mai = c(2,4,3,2)*0.2)
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(mai = c(2,4,4,2)*0.2)
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(mai = c(1,4,3,2)*0.2)
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
par(mai = c(4,4,3,2)*0.2)
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
plot(x,tf(x), type='l', col = 'blue', xlab = "t",
ylab= expression(paste(tilde(f),"(t)")))
abline(h = 0)
plot(x,tf(x), type='l', col = 'blue', xlab = "t",
ylab= expression(paste(tilde(f),"(t)")), main = "normalized signal")
abline(h = 0)
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)")
plot(x,tf(x), type='l', col = 'blue', xlab = "t",
ylab= expression(paste(tilde(f),"(t)")), main = "normalized signal")
plot(x,f(x), type='l', col = 'blue', xlab = "t", ylab= "f(t)",
main = "signal")
plot(x,tf(x), type='l', col = 'blue', xlab = "t",
ylab= expression(paste(tilde(f),"(t)")), main = "normalized signal")
abline(h = 0)
g <- function(x) {
dbeta(x,1/2,1/2)*0.1
}
plot(-x, g(x), xlim = c(-1.5,0.5),type = 'l', main = "g(x)")
tg <- function(x) {
v = rep(0, length(x))
idx <- x>0 & x<1
v[idx]<-  g(x[idx])-0.1
v
}
plot(x,tg(x), xlim = c(-0.5,1.5),type = 'l', main = "normalized K(x)", col = 'red')
abline(h=0, lty = 2)
v1  = c()
for (i in 1:length(x))
{
x0 <- x[i]
yy <- tg(x-x0)
yy[abs(yy) == Inf] = 0
v1[i] <- sum(tf(x)*yy)
}
plot(x,v1, col = 'red', type = 'l', ylim = c(-0.5,0.5), lty = 2,
ylab = expression( paste(tilde(f),"*", tilde(g))),
main = "similarity of normalized signals")
lines(x,tf(x), col='blue', lty = 2)
abline(h = 0)
legend("topright", legend = c("filtered", "original"), col = c("red", "blue"),
lty = c(2,2) )
v1  = c()
for (i in 1:length(x))
{
x0 <- x[i]
yy <- g(x-x0)
yy[abs(yy) == Inf] = 0
v1[i] <- sum(f(x)*yy)
}
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x-0.5,f(x)*6.5, col='blue')
legend("topright", legend = c("filtered", "origal with scaling"), col = c("red", "blue"),
lty = c(2,2) )
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x,f(x), col='blue')
plot(x,v1/6.5, col = 'red', type = 'l', main = "convolution")
lines(x,f(x), col='blue')
plot(x,v1, col = 'red', type = 'l', main = "convolution")
lines(x-0.5,f(x)*6.5, col='blue')
# bias
plot(x,v1, col = 'red', type = 'l', main = "convolution")
# bias
b = 0.5
# bias
b = 0.5
plot(x,v1-b, col = 'red', type = 'l', main = "convolution", lty = 2)
abline(h = 0)
plot(x,v1-b, col = 'red', type = 'l', main = "convolution", lty = 2,
ylab = "S")
abline(h = 0)
plot(x,v1-b, col = 'red', type = 'l', main = "convolution", lty = 2,
xlab = 't', ylab = "S")
abline(h = 0)
pmax(v1 - b,0)
plot(x,pmax(v1 - b,0), col = 'red', type = 'l', main = "filtered by ReLU", lty = 2,
xlab = 't', ylab = "S")
abline(h = 0)
plot(x,pmax(v1 - b,0), col = 'red', type = 'l', main = "filtered by ReLU", lty = 2,
xlab = 't', ylab = "S")
lines(x-0.5,f(x)*6.5, col='blue')
lines(x-0.5,f(x)*5.5, col='blue')
b = 0.5
plot(x,v1-b, col = 'red', type = 'l', main = "convolution", lty = 2,
xlab = 't', ylab = "S")
abline(h = 0)
plot(x,pmax(v1 - b,0), col = 'red', type = 'l', main = "filtered by ReLU", lty = 2,
xlab = 't', ylab = "S")
abline(h = 0)
100 + 170 + 140 + 140 + 170 + 140 +
175 + 140
100 + 170 + 140 + 140 + 170
140 +
175 + 140
88.24 + 90.94+92.68
88.24 + 90.94+92.68
88.24 + 90.94+92.68+ 30
88.24 + 90.94+92.68+ 15 + 5
88.24 + 90.94+92.68+ 15 + 5 + 4*6
Znbggh,
x = 100
log(x)/x
Znbggh,
x = 1000
log(x)/x
Znbggh,
x = 100000
log(x)/x
Znbggh,
x = 10000000
log(x)/x
Znbggh,
x = 10000000
log(x)/x^2
log(1/10)
Znbggh,
x = 0.2
log(x)/x^2
Znbggh,
x = 0.001
log(x)/x^2
log(x)*x^2
log(1/10)
Znbggh,
x = 0.001
log(x)*x^2
Znbggh,
x = 0.00001
log(x)*x^2
Znbggh,
x = 0.0000001
log(x)*x^2
Znbggh,
x = 0.0000001
-log(x)  - 1/x^2
Znbggh,
x = 0.0001
-log(x)  - 1/x^2
Znbggh,
x = 0.01
-log(x)  - 1/x^2
Znbggh,
x = 0.0000000001
-log(x)  - 1/x^2
-log(x)
x = 0.000000000001
-log(x)
4.55*6
88.24+90.94+92.68 + 47.3
20000/365
15000/365
15000/10
15000/10*1450
15000/20*1450
15000/20*1450*5
install.packages("Rcpp")
library(Rcpp)
set.seed(3)
p = 3
n = 50
n1 <- rpois(n,3) + 2
n1
n1[n1>p] = p
a  <- vector(mode = "list", length = n)
a
mu.true = rep( seq(3,1, length = 5), each = 10)
logmu.true = log(mu.true)
i=1
for (i in 1:n)
{
gp<-sort(sample(1:p, n1[i]))
z <- rgev(n1[i]) + logmu.true[gp]
ix.tmp <- sort(z, decreasing = T, index.return = T)$ix
a[[i]] <- gp[ix.tmp]
}
library(evd)
install.package("evd")
install.packages("evd")
library(evd)
mu.true = rep( seq(3,1, length = 5), each = 10)
mu.true
logmu.true = log(mu.true)
i=1
for (i in 1:n)
{
gp<-sort(sample(1:p, n1[i]))
z <- rgev(n1[i]) + logmu.true[gp]
ix.tmp <- sort(z, decreasing = T, index.return = T)$ix
a[[i]] <- gp[ix.tmp]
}
ilist = jlist = vector(mode="list", length = p)
############### comlasso
ns <- c(50)
ps <- c(50)
parset <- matrix(0,length(ns)*length(ps),2)
runtime.list <- vector(mode="list",length=nrow(parset))
cnt <- 0
for(ii in 1:length(ns)){
for(jj in 1:length(ps)){
cnt <- cnt+1
parset[cnt,] <- c(ns[ii],ps[jj])
}
}
parset
ll = 1
n <- parset[ll,1] ; p <- parset[ll,2]
sigma <- 0.2^(abs(outer(1:p,1:p,"-")))
diag(sigma) <- 1
mm<-rep(0,p);mm[1:5]<-p/2;mm[6:p]<-1
n
p
p <- 50
sigma <- 0.2^(abs(outer(1:p,1:p,"-")))
sigma
diag(sigma) <- 1
mm<-rep(0,p);mm[1:5]<-p/2;mm[6:p]<-1
w <- mvlognormal(n=n, Mu=mm,Sigma=rep(1,p),R=sigma);
z <- diag(1/rowSums(w)) %*% w
w <- mvlognormal(n=n, Mu=mm,Sigma=rep(1,p),R=sigma);
library("MethylCapSig")
w <- mvlognormal(n=n, Mu=mm,Sigma=rep(1,p),R=sigma);
z <- diag(1/rowSums(w)) %*% w
w
z
b <- rep(0,p)
b[1:16] <- c(1,-0.8,0.4,0,0,-0.6,0,0,0,0,-1.5,0,1.2,0,0,0.3)
sum(b)
y <- drop(z %*% b)+rnorm(n,0,0.5^2)
y
m <- matrix(0,8,p)
Cm[1,1:10]<-1;Cm[2,11:16]<-1;
Cm[3,17:20]<-1;Cm[4,21:23]<-1;
Cm[5,24:30]<-1;Cm[6,31:32]<-1;
Cm[7,33:40]<-1;Cm[8,41:p]<-1;
Cm <- matrix(0,8,p)
Cm[1,1:10]<-1;Cm[2,11:16]<-1;
Cm[3,17:20]<-1;Cm[4,21:23]<-1;
Cm[5,24:30]<-1;Cm[6,31:32]<-1;
Cm[7,33:40]<-1;Cm[8,41:p]<-1;
drop(Cm%*%b)
y
z
dim(z)
8
n
8
n
n = 10
p
p = 3
K = c(3,3,4)
y
z = matrix(rnorm(n*length(K)), n, length(K))
sourceCpp('inner.cpp')
# Rtools is required and Path for rtools should be set.
library(inline)
library(RcppArmadillo)
setwd("D:/Jeon/rcode/ComLasso/test")
sourceCpp('inner.cpp')
rm(list = ls()) ; gc()
# Rtools is required and Path for rtools should be set.
library(inline)
library(RcppArmadillo)
setwd("D:/Jeon/rcode/ComLasso/test")
sourceCpp('inner.cpp')
# Rtools is required and Path for rtools should be set.
library(Rcpp)
library(inline)
library(RcppArmadillo)
setwd("D:/Jeon/rcode/ComLasso/test")
sourceCpp('inner.cpp')
inner2(1:3)
inner2(1:3,4:6)
inner2(1:3,4:6)
rm(list = ls())
gc()
DataFolder <- "D:/Jeon/gd/JUVIS_JJJ/data"
SourceFolder <- "D:/Jeon/rcode/juvis_repository/library"
setwd(DataFolder)
rwdata <- read.csv("juvis_tmp.csv", stringsAsFactors = F)
# load library
library(MASS)
library(reshape2)
library(dplyr)
library(ggplot2)
source(file = paste0(SourceFolder,"/juvis_fun.R"))
rdata <- rwdata %>% filter( is.na(prg_type) == F ) %>%
filter(prg_type == "A"|
prg_type == "I"|
prg_type == "K")
# List of considered Variables
# prg_type    : program type of customers
# bca_wt      : body weight
# bca_protein : protein
# bca_mineral : mineral
# bca_bfm     :
# wc_age      : age
# wc_ht       : height
# wc_sex      : sex
# Set up Data file and Variables
# Note that the program type is chosen here
tdata <- rdata %>% filter(mem_id!='') %>%
filter(prg_type =="A") %>%
select(mem_id, ctr_id, bca_datetimes,
cht_date, bca_wt,
bca_tbw, bca_protein, bca_mineral,bca_bfm,
wc_age, wc_sex, wc_sex)
mem_id <- unique(tdata$mem_id)
# What response variables are analyzed?
p = 4
beta.mat <- matrix(NA,length(mem_id), p)
varinfo  <- matrix(NA,length(mem_id), p)
# set response list  (input)
response_list = c("bca_mineral", "bca_protein","bca_tbw","bca_bfm")
colnames(beta.mat) <- response_list
# Regression analysis (huberized regression)
for ( i in 1:length(mem_id))
{
if ( i%%1000 == 0 ) cat(i,'\n')
tmp <- tdata[tdata$mem_id == mem_id[i] ,]
numObs<- nrow(tmp)
# screen 1 (lack of total # of data)
if (numObs <= 5) next
tmp$ctr_id <- as.factor(tmp$ctr_id)
levelLength <- length(levels(tmp$ctr_id))
# screen 2 (efficienty of statistical inferences)
if (numObs <= 3*levelLength) next
# use huberized regression to avoid outlier-problem
for (j in 1:p)
{
if(levelLength == 1)
{
tmp.formula <- as.formula(paste( response_list[j], " ~ bca_wt", sep = ""))
if (any(is.na(tmp[response_list[j]]))) next
fit <- rlm(tmp.formula, data = tmp)
# regression coefficients
beta.mat[i,j] <- fit$coefficients["bca_wt"]
# variance informations
varinfo[i,j] <- sd(tmp[[response_list[j]]], na.rm = TRUE)
}
if(levelLength > 1)
{
tmp.formula <- as.formula(paste( response_list[j],
" ~ ctr_id + bca_wt", sep = ""))
if (any(is.na(tmp[response_list[j]]))) next
fit <- rlm(bca_mineral~ ctr_id + bca_wt, data = tmp)
# regression coefficients
beta.mat[i,j] <-fit$coefficients["bca_wt"]
# variance informations
varinfo[i,j] <- sd(tmp[[response_list[j]]], na.rm = TRUE)
}
}
}
sel_obs <- !is.na(beta.mat[,1])
beta.mat_anal <- beta.mat[sel_obs,]
mem_id_anal <- mem_id[sel_obs]
vartmp <- varinfo[sel_obs,1]
# process for deleting outliers
valBIC = Inf
Kval = 3
for ( k in 3:10)
{
kmeanFit<- kmeans(vartmp,centers = k)
v <- kmeansBIC(kmeanFit)
if ( v<valBIC)   valBIC <- v else
{
kVal = k-1
break
}
}
kmeanFit<- kmeans(vartmp,centers = kVal)
selvar <- order(kmeanFit$size, decreasing = T)[1]
sel_obs <- kmeanFit$cluster %in% selvar
result_mat <- as.data.frame(beta.mat_anal[sel_obs,])
kmeanFit
setwd("D:/Jeon/rcode/ComLasso/test")
sourceCpp('inner.cpp')
sourceCpp('inner.cpp')
?gctorture
sourceCpp('inner.cpp')
add1(1:3)
class(add1(1:3))
sourceCpp('inner.cpp')
add1(1:3)
add1(1:3)
sourceCpp('inner.cpp')
add1(1:3)
sourceCpp('inner.cpp')
sourceCpp('inner.cpp')
test(3:1,3:1)
testFun(3:1,3:1)
sourceCpp('inner.cpp')
testFun(3:1,3:1)
testFun(10:8,3:1)
sourceCpp('inner.cpp')
testFun(10:8,3:1)
